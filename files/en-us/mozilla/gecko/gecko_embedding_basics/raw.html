<p><!-- {{ Outdated("It was last updated a very long time ago.") }} --></p>

<p>Given the ever-growing importance of the Web as a source of information, entertainment, and personal connectedness, the ability to access and view data stored in HTML format is becoming more and more important for a wide variety of otherwise highly divergent software applications. Whether it's a matter of a simple HTML page viewer or of a full-fledged web browser, the ability to parse and render HTML-based documents is an increasingly significant function in many, many situations. For the application developer, the problem becomes how to implement this crucial functionality in a way that minimizes development time yet results in an agile and robust product. Embedding Gecko, the rendering engine at the heart of the Netscape and Mozilla browsers, is an outstanding solution to this problem.</p>

<h2 id="Why_Gecko" name="Why_Gecko">Why Gecko</h2>

<p>Gecko is the smart embedding choice. It is quick, robust, and highly standards compliant. In its Mozilla and Netscape incarnations, it has been widely distributed and very well reviewed.</p>

<p>It is Open Source. Unlike other embedding choices, all of Gecko's source code is freely available and fully customizable. You can tinker and tweak as much as you need. Yet, depending on the license chosen, it is quite possible to use Gecko as a component in what is otherwise a fully proprietary commercial product.</p>

<p>Because Gecko is associated with the Mozilla project, there are many resources available to assist the embedding effort. The Mozilla <a class="external" href="http://www.mozilla.org">web site</a>, has an <a class="external" href="http://mozilla.org/projects/embedding/">embedding project area</a>. There is a newsgroup, mozilla.dev.embedding, focussed on exchanging information among embedders, as well as a number of other related newsgroups. A complete <a class="external" href="http://lxr.mozilla.org/seamonkey">cross-reference for the codebase</a> is available, and filing, following the progress of, and helping to fix any bugs is made simple through the <a class="external" href="http://bugzilla.mozilla.org/">Bugzilla bug database</a>.</p>

<p>Gecko is also architected from the ground up to be cross-platform. Directly from mozilla.org, it runs on Wintel, Mac OS 9.0 and OS X, and Linux, and there are third-party ports to a number of other platforms.</p>

<p>Finally, licensing Gecko is royalty-free, even if the final application is an otherwise proprietary commercial product. <em>Very</em> generally, any modifications of the original Mozilla-supplied source code (but not the code in which it is embedded) must be returned to the community, that same original code must be made available to the application's users (often by a link to the mozilla.org website), and the application must indicate in some obvious way (for example, a logo on the box or on the About: page) that the product embeds Gecko. Exact descriptions of the possible licensing arrangements are presented at <a class="external" href="http://www.mozilla.org/MPL/">Mozilla &amp; Netscape Public Licenses</a>, which is the only legally complete source for licensing information.</p>

<h2 id="What_You_Need_to_Embed" name="What_You_Need_to_Embed">What You Need to Embed</h2>

<p>Once you've decided to embed, there are three main steps that you must take. First you must get the code. Then you must understand some specific technologies used in the manipulation of the Gecko codebase. Finally, you must decide which additional functionalities you may wish to add. This section will guide you through these steps.</p>

<h3 id="Getting_the_Code" name="Getting_the_Code">Getting the Code</h3>

<p>At the moment, the best way to get the files you will need to embed Gecko is to download and build the entire Mozilla source tree. This is actually a fairly simple process. Full instructions and appropriate links are available at <a href="/en-US/Developer_Guide/Source_Code/Downloading_Source_Archives" title="en/Mozilla_Source_Code_(HTTP//FTP)">Download Mozilla Source Code</a>. A second, component by component, method is under development, but is still at a beta stage. Information on this project can be found at <a class="external" href="http://www.mozilla.org/projects/embedding/bootstrap.html">REQUIRES-based build mechanism</a>. In addition, work is also being done on developing a Gecko Runtime Environment, or <a href="/en/GRE" title="en/GRE">GRE</a>, which would support multiple applications built on Mozilla components using a single set of core libraries. (If you intend to work component by component you must be particularly aware of issues of versioning and binary compatibility. For help in this area, look at <a class="external" href="http://mozilla.org/projects/xpcom/glue/Component_Reuse.html">XPCOM Component Reuse</a>.)</p>

<p>First you must acquire some tools (basically a supported compiler, a Perl distribution, and some general purpose utilities). Then you must set up your computer environment. Next you must download the source. Assuming you are going to download the entire tree, there are two ways to do this: you can FTP a tarball of the entire tree (this is the simplest way, and it's guaranteed to compile, but it may not include the most recent additions to the code) or you can use CVS to get the absolutely most recent code or to do incremental updates. Once you have the tree and the tools and your environment is properly set up, all you have to do is run the appropriate provided makefile. There are detailed instructions for each of the supported platforms.</p>

<p>When the build is done, navigate to the mozilla/embedding/config directory. There you will find sample manifest files (all the names begin with "basebrowser") for embedding on each of the different platforms. These are samples only and they may not fit your needs completely, but they are a good place to start. There are also sample embedding projects for each platform that you can use as models. See <a class="external" href="http://mozilla.org/projects/embedding/examples/index.html">Embedding: Mozilla Examples and External Projects</a>.</p>

<h3 id="Understanding_the_Coding_Environment" name="Understanding_the_Coding_Environment">Understanding the Coding Environment</h3>

<p>Mozilla was set up from the beginning to support design and development across multiple platforms and programming languages. To this end, a number of in-house programming technologies were developed, all based around an ideal of object encapsulation. Embedding Gecko necessarily implies acquiring a working knowledge of these technologies, including XPCOM, XPIDL, XPConnect, special string classes, and, optionally, XUL. The following provides a brief introduction to them. More information can be found at the mozilla.org site.</p>

<h4 id="XPCOM" name="XPCOM">XPCOM</h4>

<p>The most important of the Mozilla technologies is <a href="/en/XPCOM" title="en/XPCOM">XPCOM</a>, the Cross-Platform Component Object Model. XPCOM provides a framework which manages the creation, ownership, and deletion of objects and other data throughout Mozilla. If you have used MSCOM, you will recognize certain basic similarities. But there are also significant differences -- XPCOM is cross-platform and designed to run largely in a single thread -- and the two are not at this time compatible.</p>

<h5 id="The_interface" name="The_interface">The interface</h5>

<p>At the core of XPCOM is the concept of the interface. An interface is simply a description of a set of methods, attributes, and related constants all associated with a particular functionality: it is completely distinct from the class that implements those things. The interface serves as a kind of contract: any object that supports a particular interface guarantees that it will perform the services described in it. To keep the interface as language neutral as possible, it is written in a special language, the Interface Definition Language, or IDL. Interface files are often referred to as .idl files. In addition to specifying the functionality of the interface, these files also carry the interface's IID, its globally unique identifying number.</p>

<p>Much of the communication within Gecko takes place in terms of these abstract structures (by convention, their names follow the form <code>nsISomething</code>).</p>

<pre>//this
void ProcessSample(nsISample* aSample) {
	aSample-&gt;Poke("Hello");
//not this
void ProcessSample(nsSampleImpl* aSample) {
	aSample-&gt;Poke("hello");
</pre>

<h5 id=".40status_FROZEN" name=".40status_FROZEN">@status FROZEN</h5>

<p>XPCOM's level of abstraction produces great flexibility in the system. Implementations are free to change as needed. But, to work, the interfaces themselves must remain fixed. Throughout Mozilla's initial design and development period, interfaces have been somewhat fluid, but as the project has matured, more and more of the interfaces have been marked FROZEN. Any interface so marked is guaranteed not to change in the future.</p>

<p>Most of the main interfaces key to the embedding effort are now frozen, but it's always a good idea to check before using any interface. An interface's status is listed in the .idl file's comments. A frozen interface is marked <code>@status FROZEN</code>. You can <a class="external" href="http://lxr.mozilla.org/seamonkey/search?string=%40status+FROZEN">search for frozen interfaces</a> by using the Mozilla cross referencing tool. Until it is frozen, an interface may change at any time. For more information on the freezing process, see the <a class="external" href="http://mozilla.org/projects/embedding/">embedding project page</a>.</p>

<p>Once an interface has been frozen, it is added to the <a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi.html">Gecko Embedding API Reference</a>.</p>

<h5 id="nsISupports" name="nsISupports">nsISupports</h5>

<p>A single object can support more than one interface. In fact, essentially all objects support at least two interfaces -- a minimum of one that does something specifically useful and one, <code>nsISupports</code>, that serves a more general purpose. In a sense, <code>nsISupports</code> is the progenitor of all XPCOM interfaces. All interfaces inherit from it, most directly so. It serves two main functions: runtime type discovery and object lifetime management. It is functionally identical to IUnknown in MSCOM.</p>

<p>Since an object can support multiple interfaces, it's possible to have a pointer to one interface and want to know whether that same object also supports a different interface whose functionality you might also need. The first <code>nsISupports</code> method, <code>QueryInterface()</code>, does exactly that: it asks, in effect, "I know that this object is of type A (supports interface A) but is it also of type B (supports interface B)?"</p>

<p>If it is (or does), <code>QueryInterface()</code> returns to the caller a pointer bound to the newly requested interface.</p>

<pre>void ProcessSample(nsISample* aSample) {
	nsIExample *example;
	nsresult rv;
	rv = aSample-&gt;QueryInterface(NS_GET_IID(nsIExample),(void **)&amp;example);
	if (NS_SUCCEEDED(rv)) {
		example-&gt;DoSomeOperation();
		NS_RELEASE(example); // using a macro to call Release
	}
}
</pre>

<p>Because XPCOM uses an indirect method, the Component Manager, to actually instantiate objects, and because multiple pointers to the same object -- often bound to different interfaces -- can exist, it can quickly become very difficult for callers to keep accurate track of all of the objects to which those pointers point. Objects could be kept around in memory longer than they need to be, causing leaks, or objects could be deleted prematurely, causing dangling pointers. The other two methods in <code>nsISupports</code>, <code>AddRef()</code> and <code>Release()</code>, are designed to deal with this issue. Every time a pointer is given out <code>AddRef()</code> must be called on the object, incrementing an internal counter. Every time a pointer is released, <code>Release()</code> must be called, which decrements that same counter. When the counter reaches zero, there are no pointers to the object remaining and the object can safely delete itself. Control of the object's lifetime stays within the object itself. See below for information on XPCOM's "smart" pointer, <a href="#nsCOMPtr">nsCOMPtr</a>, a utility which helps automate this process.</p>

<h5 id="Object_creation" name="Object_creation">Object creation</h5>

<p>The instantiation of objects is also an indirect process in XPCOM. Just as interfaces have a globally unique ID number (the IID), XPCOM classes are assigned their own GUIDs, the CID. In addition, they are also often given a text-based ID, called a contract ID. One or the other of these IDs is passed to a method on a persistent XPCOM component, the Component Manager, which actually creates the object. When a new library of classes (called a module in XPCOM) is first introduced into the system, it must register itself with the Component Manager, which maintains a registry that maps classes (with their IDs) to the libraries in which they reside.</p>

<p>A limited number of persistent services, supplied by singleton objects, are created and controlled by a companion to the Component Manager, the Service Manager. The Component Manager itself is an example of such a persistent service.</p>

<h5 id="Summing_up" name="Summing_up">Summing up</h5>

<p>Functionality in XPCOM is described by abstract interfaces, and most communication among parts of the system takes place in terms of those interfaces. The underlying objects that implement the interfaces, on the other hand, are created indirectly by the Component Manager based on a cross-indexed registry that it maintains.</p>

<p>One functionality shared by all interfaces is the ability to query the underlying object at runtime to see if also implements other interfaces. In theory an interface is fixed and unchangeable, but at this stage in the Mozilla codebase, only interfaces that have been declared <code>FROZEN</code> are guaranteed not to change significantly. Object lifetime management takes place inside the object itself through an internal counter that keeps track of the number of pointers to the object that have been added or released. The client's only responsibility is to increment and decrement the counter. When the internal counter reaches zero, the object deletes itself.</p>

<h5 id="nsCOMPtr" name="nsCOMPtr">nsCOMPtr</h5>

<p>Sometimes, however, even remembering to call <code>AddRef()</code> and <code>Release()</code> at the right times can be difficult. To make this process easier and more reliable, XPCOM has a built-in "smart" pointer, <code>nsCOMPtr</code>. This pointer takes care of calling <code>AddRef()</code> and <code>Release()</code> for you. Using <code>nsCOMPtr</code> whenever possible will make your code cleaner and more efficient. For more information on the smart pointer, see "<a class="external" href="http://www.mozilla.org/projects/xpcom/nsCOMPtr.html">The Complete nsCOMPtr User's Manual</a>".</p>

<p>Mozilla actually provides a large number of built-in macros (by convention, written in all caps in the code) and utilities like <code>nsCOMPtr</code> that can make the entire process of coding with XPCOM easier. Many of these can be found in the following files: <code>nsCom.h</code>, <code>nsDebug.h</code>, <code>nsError.h</code>, <code>nsIServiceManager.h</code>, and <code>nsISupportsUtils.h</code>. Mozilla also supplies other development tools for tracking memory usage and the like. More information on these can be found at <a class="external" href="http://www.mozilla.org/performance/" rel="freelink">http://www.mozilla.org/performance/</a></p>

<h5 id="For_more_information" name="For_more_information">For more information</h5>

<p>More information on XPCOM in general can be found at <a href="/en/XPCOM" title="en/XPCOM">XPCOM</a>. For an overview of creating XPCOM components, see Chapter 8 of O'Reilly's <em><a class="external" href="http://books.mozdev.org/chapters/ch08.html">Creating Applications with Mozilla</a></em>. There is also a new book completely devoted to this topic, <em><a href="/en/Creating_XPCOM_Components" title="en/Creating_XPCOM_Components">Creating XPCOM Components</a></em>. A fuller explanation of some of the underlying logic to COM systems can be found in the early chapters of <em>Essential COM</em> by Don Box. While it focuses on MSCOM in particular, the book does provide an excellent background on some of the core rationales for using such an object model.</p>

<h4 id="XPIDL" name="XPIDL">XPIDL</h4>

<p>Interfaces are abstract classes written in XPIDL, the Cross Platform Interface Definition Language. Yet to be useful the functionality promised in those interfaces must be implemented in some regular programming language. Facilitating this is the job of the XPIDL compiler. Once an interface is defined in an .idl file, it can be processed by the XPIDL compiler.</p>

<p>The compiler can be set to output a number of things, but generally the output is two-fold: a C++ .h file that includes a commented out template for a full C++ implementation of the interface and an XPT file that contains type library information which works with XPConnect to make the interface available to JavaScript. More information on the syntax of <a href="/en/XPIDL" title="en/XPIDL">XPIDL</a> (a simple C-like language) and the use of the <a href="/en/XPIDL/xpidl" title="en/XPIDL/xpidl">compiler</a> is available.</p>

<h4 id="XPConnect_and_XPT_files" name="XPConnect_and_XPT_files"><a href="/en/XPConnect" title="en/XPConnect">XPConnect</a> and XPT files</h4>

<p><a href="/en/XPConnect" title="en/XPConnect">XPConnect</a> is an <a href="/en/XPCOM" title="en/XPCOM">XPCOM</a> module that allows code written in <a href="/en/JavaScript" title="en/JavaScript">JavaScript</a> to access and manipulate XPCOM components written in C++ and vice versa. By means of XPConnect, components on either side of an XPCOM interface do not, in general, need to know or care about which of these languages the object on the other side is implemented in.</p>

<p>When an interface is run through the XPIDL compiler, it produces an XPT or type library file. Because XPconnect uses the information in this file to implement transparent communication between C++ objects and JavaScript objects across XPCOM interfaces, it is important to make sure they are generated and included with your code even if you are developing exclusively in C++. Not only is a substantial part of the browser, in fact, implemented in JS, it is possible that in the future someone may wish to use JS-based code to interact with whatever components you create .</p>

<p>As is from Mozilla, XPConnect currently facilitates interoperability between C++ and JS. Modules to extend it to allow access from other languages (including Python) are under independent development.</p>

<h4 id="String_classes" name="String_classes">String classes</h4>

<p>Web browsing typically involves a large amount of string manipulation. Mozilla has developed a hierarchy of C++ classes to facilitate such manipulation and to render it efficient and quick. To make communication among objects simpler and more error free, Mozilla uses interfaces, which are, in essence, abstract classes. The string hierarchy is also headed up by a set of abstract classes, <code>nsAString</code>, <code>nsASingleFragmentString</code>, and <code>nsAFlatString</code>, and for the same reasons. (These refer to double-byte strings. There is a parallel hierarchy topped with <code>nsACString</code>, etc., that refers to single-byte strings.) <code>nsAString</code> guarantees only a string of characters. <code>nsASingleFragmentString</code> guarantees that the characters will be stored in a single buffer. <code>nsAFlatString</code> guarantees that the characters will be stored in a single null-terminated buffer. While there are underlying concrete classes, in general it is best to use the most abstract type possible in a given situation. For example, concantenation can be done virtually, through the use of pointers, resulting in an nsAString that can be used like any other string. This saves the allocating and copying that would otherwise have to be done. For more information, see "<a href="/En/Mozilla_internal_string_guide" title="En/Mozilla_internal_string_guide">XPCOM string guide</a>".</p>

<h4 id="XUL.2FXBL" name="XUL.2FXBL">XUL/XBL</h4>

<p>Use of this final Mozilla technology is optional, depending on how you decide to create the user interface for your application. <a href="/en/XUL" title="en/XUL">XUL</a> is Mozilla's highly flexible XML UI Language. It provides a number of largely platform independent widgets from which to construct a UI. Netscape and Mozilla both use XUL for their interfaces, but not all embedders choose to use it. XBL or the eXtensible Binding Language allows you to attach behaviors to XUL's XML elements. More information on XUL can be found at <a class="external" href="http://www.mozilla.org/xpfe/xulref/">XUL Programmer's Reference</a> and on <a href="/en/XBL" title="en/XBL">XBL</a> at <a href="/en/XBL/XBL_1.0_Reference" title="en/XBL/XBL_1.0_Reference">XBL:XBL_1.0_Reference</a>. There is also a wealth of good information on XUL at <a class="external" href="http://www.xulplanet.com/">XULPlanet</a>.</p>

<h3 id="Choosing_Additional_Functionalities" name="Choosing_Additional_Functionalities">Choosing Additional Functionalities</h3>

<p>As of this writing (8/19/02), Gecko is a partially modularized rendering engine. Some functionalities beyond basic browsing are always embedded with Gecko, and, as a result of certain architectural decisions, always will be; some are at present always embedded with Gecko, but may, at some point in the future, be separable; and some are now available purely as options. The following table describes the present status of these additional functionalities:</p>

<table>
 <tbody>
  <tr>
   <th>Functions</th>
   <th>Status Now</th>
   <th>Status in Future</th>
  </tr>
  <tr>
   <td>FTP support</td>
   <td>Optional</td>
   <td> </td>
  </tr>
  <tr>
   <td>HTTPS support</td>
   <td>Optional</td>
   <td> </td>
  </tr>
  <tr>
   <td>International character support</td>
   <td>Optional</td>
   <td> </td>
  </tr>
  <tr>
   <td>XUL support</td>
   <td>Required</td>
   <td>Probably optional</td>
  </tr>
  <tr>
   <td>Network support</td>
   <td>Required</td>
   <td>Maybe optional</td>
  </tr>
  <tr>
   <td>JavaScript support</td>
   <td>Required</td>
   <td>Maybe optional</td>
  </tr>
  <tr>
   <td>CSS support</td>
   <td>Required</td>
   <td>Always required</td>
  </tr>
  <tr>
   <td>DOM support</td>
   <td>Required</td>
   <td>Probably always</td>
  </tr>
  <tr>
   <td>XML support</td>
   <td>Required</td>
   <td>Probably always</td>
  </tr>
 </tbody>
</table>

<p>At this time embedding Mozilla's editor along with the rendering engine Gecko is an uncertain proposion, although the situation continues to improve. For more information on the status of the embeddable editor, see <a class="external" href="http://www.mozilla.org/editor/Editor_Embedding_Guide.html" rel="freelink">http://www.mozilla.org/editor/Editor...ing_Guide.html</a>.</p>

<h2 id="What_Gecko_Provides" name="What_Gecko_Provides">What Gecko Provides</h2>

<p>The following is a description of some of the interfaces most commonly used in embedding Gecko. It is by no means an exhaustive list of the available interfaces. The interfaces in this section are on classes provided by Mozilla. There is also a set of interfaces for which Gecko expects the embedder to provide the implementation. A sample of those are covered in the next section.</p>

<h3 id="Initialization_and_Teardown" name="Initialization_and_Teardown">Initialization and Teardown</h3>

<p>There are two C++ only functions which serve to initalize and terminate Gecko. The initialization function (<a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi2.html#1099700">NS_InitEmbedding</a>) must be called before attempting to use Gecko. It ensures XPCOM is started, creates the component registry if necessary, and starts global services. The shutdown function (<a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi2.html#1101115">NS_TermEmbedding</a>) terminates the Gecko embedding layer, ensuring that global services are unloaded, files are closed and XPCOM is shut down.</p>

<h3 id="nsIWebBrowser" name="nsIWebBrowser"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi4.html">nsIWebBrowser</a></h3>

<p>Use of this interface during initialization allows embedders to associate a new <code>nsWebBrowser</code> instance (an object representing the "client-area" of a typical browser window) with the embedder's chrome and to register any listeners. The interface may also be used at runtime to obtain the content DOM window and from that the rest of the DOM.</p>

<p>The XULPlanet <code>nsWebBrowser</code> reference also has a lot of useful information on this class.</p>

<h3 id="nsIWebBrowserSetup" name="nsIWebBrowserSetup"><a class="external" href="http://www.mozilla.org/projects/embedding/embedapiref/embedapi10.html">nsIWebBrowserSetup</a></h3>

<p>This interface is used to set basic properties (like whether image loading will be allowed) before the browser window is open.</p>

<h3 id="nsIWebNavigation" name="nsIWebNavigation"><a class="external" href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIWebNavigation.html">nsIWebNavigation</a></h3>

<p>The <code>nsIWebNavigation</code> interface is used to load URIs into the web browser instance and provide access to session history capabilities - such as back and forward. As of June 6, 2006, this interface is not yet frozen.</p>

<h3 id="nsIWebBrowserPersist" name="nsIWebBrowserPersist"><a class="external" href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIWebBrowserPersist.html">nsIWebBrowserPersist</a></h3>

<p>The <code>nsIWebBrowserPersist</code> interface allows a URI to be saved to file. As of June 6, 2006, this interface is not yet frozen.</p>

<h3 id="nsIBaseWindow" name="nsIBaseWindow"><a class="external" href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIBaseWindow.html">nsIBaseWindow</a></h3>

<p>The <code>nsIBaseWindow</code> interface describes a generic window and basic operations (size, position, window title retrieval, etc.) that can be performed on it. As of June 6, 2006, this interface is not yet frozen.</p>

<h3 id="nsISHistory" name="nsISHistory"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi58.html">nsISHistory</a></h3>

<p>The <code>nsISHistory</code> interface provides access to session history information and allows that information to be purged.</p>

<h3 id="nsIWebBrowserFind" name="nsIWebBrowserFind"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi14.html">nsIWebBrowserFind</a></h3>

<p>The <code>nsIWebBrowserFind</code> interface controls the setup and execution of text searches in the browser window.</p>

<h2 id="What_You_Provide" name="What_You_Provide">What You Provide</h2>

<p>The following is a description of some of the more common embedder-provided interfaces used in embedding Gecko. It is by no means an exhaustive list of the available interfaces.</p>

<h3 id="nsIWebBrowserChrome" name="nsIWebBrowserChrome"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi6.html">nsIWebBrowserChrome</a></h3>

<p>The <code>nsIWebBrowserChrome</code> interface corresponds to the top-level, outermost window containing an embedded Gecko web browser. You associate it with the WebBrowser through the <code>nsIWebBrowser</code> interface. It provides control over window setup and whether or not the window is modal. It must be implemented.</p>

<h3 id="nsIEmbeddingSiteWindow" name="nsIEmbeddingSiteWindow"><a class="external" href="http://www.mozilla.org/projects/embedding/embedapiref/embedapi12.html">nsIEmbeddingSiteWindow</a></h3>

<p>The <code>nsIEmbeddingSiteWindow</code> interface provides Gecko with the means to call up to the host to resize the window, hide or show it and set/get its title. It must be implemented.</p>

<h3 id="nsIWebProgressListener" name="nsIWebProgressListener"><a href="/en/nsIWebProgressListener" title="en/nsIWebProgressListener">nsIWebProgressListener</a></h3>

<p>The <code>nsIWebProgressListener</code> interface provides information on the progress of loading documents. It is added to the WebBrowser through the <code>nsIWebBrowser</code> interface. It must be implemented. As of this writing (8/19/02), it is not frozen.</p>

<h3 id="nsISHistoryListener" name="nsISHistoryListener"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi59.html">nsISHistoryListener</a></h3>

<p>The <code>nsISHistoryListener</code> interface is implemented by embedders who wish to receive notifications about activities in session history. A history listener is notified when pages are added, removed and loaded from session history. It is associated with Gecko through the <code>nsIWebBrowser</code> interface. Implementation is optional.</p>

<h3 id="nsIContextMenuListener" name="nsIContextMenuListener"><a class="external" href="http://mozilla.org/projects/embedding/embedapiref/embedapi5.html">nsIContextMenuListener</a></h3>

<p>The <code>nsIContextMenuListener</code> interface is implemented by embedders who wish to receive notifications for context menu events, i.e. generated by a user right-mouse clicking on a link. It should be implemented on the web browser chrome object associated with the window for which notifications are required. When a context menu event occurs, the browser will call this interface if present. Implementation is optional.</p>

<h3 id="nsIPromptService" name="nsIPromptService"><a href="/en/XPCOM_Interface_Reference/nsIPromptService" title="en/nsIPromptService">nsIPromptService</a></h3>

<p>The <code>nsIPromptServices</code> interface allows the embedder to override Mozilla's standard prompts: alerts, dialog boxes, and check boxes and so forth. The class that implements these embedder specific prompts must be registered with the Component Manager using the same CID and contract ID that the Mozilla standard prompt service normally uses. Implementation is optional. As of this writing (8/19/02), this interface is not frozen.</p>

<h2 id="Common_Embedding_Tasks" name="Common_Embedding_Tasks">Common Embedding Tasks</h2>

<p>The following is a series of code snippets (taken from MFCEmbed, the Windows based embedding Gecko sample) which demonstrate very briefly implementation associated with common embedding tasks. MFCEmbed code was deleted from the current repository as the code quality was not very high and it did not use good embedding APIs. If you need a MFC embedding example, maybe take a look at the K-Meleon source. There are also Linux- and Mac OS-based examples, see <a class="external" href="http://mxr.mozilla.org/mozilla-central/source/embedding/tests/" title="http://mxr.mozilla.org/mozilla-central/source/embedding/tests/">http://mxr.mozilla.org/mozilla-central/source/embedding/tests/</a> for a list of examples.</p>

<h3 id="Gecko_setup" name="Gecko_setup">Gecko setup</h3>

<p>The Gecko embedding layer must be initialized before you can use Gecko. This ensures XPCOM is started, creates the component registry if necessary, and starts global services. There is an equivalent shutdown procedure.</p>

<p>Note that the embedding layer is started up by passing it two parameters. The first indicates where the executable is stored on the file system (<code>nsnull</code> indicates the working directory). The second indicates the file location object "provider" that specifies to Gecko where to find profiles, the component registry preferences, and so on.</p>

<pre>nsresult rv;
rv = NS_InitEmbedding(nsnull, provider);
if(NS_FAILED(rv))
{
ASSERT(FALSE);
return FALSE;
}
</pre>

<h3 id="Creating_a_browser_instance" name="Creating_a_browser_instance">Creating a browser instance</h3>

<p>The embedder-provided BrowserView object calls its method <code>CreateBrowser()</code>. Each browser object (a webbrowser) represents a single browser window. Notice the utility directive <code>do_CreateInstance()</code> and the use of macros.</p>

<pre>//Create an instance of the Mozilla embeddable browser

HRESULT CBrowserView::CreateBrowser()
{
// Create a web shell
nsresult rv;
mWebBrowser = do_CreateInstance(NS_WEBBROWSER_CONTRACTID, &amp;rv);
if(NS_FAILED(rv))
return rv;
</pre>

<p>Once the <code>nsWebBrowser</code> object is created the application uses <code>do_QueryInterface()</code> to load a pointer to the <a class="external" href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIWebNavigation.html">nsIWebNavigation</a> interface into the <code>mWebNav</code> member variable. This will be used later for web page navigation.</p>

<pre>rv = NS_OK;
mWebNav = do_QueryInterface(mWebBrowser, &amp;rv);
if(NS_FAILED(rv))
return rv;
</pre>

<p>Next the embedder-provided <code>CBrowserImpl</code> object is created. Gecko requires that some interfaces be implemented by the embedder so that Gecko can communicate with the embedding application. See the <a href="#What_You_Provide">What You Provide Section</a>. In the sample, <code>CBrowserImpl</code> is the object that implements those required interfaces. It will be passed into the <code>SetContainerWindow()</code> call below.</p>

<pre>mpBrowserImpl = new CBrowserImpl();
if(mpBrowserImpl == nsnull)
return NS_ERROR_OUT_OF_MEMORY;
</pre>

<p>The <code>mWebBrowser</code> interface pointer is then passed to the <code>CBrowserImpl</code> object via its <code>Init()</code> method. A second pointer to the platform specific <code>BrowserFrameGlue</code> interface is also passed in and saved. The <code>BrowserFrameGlue</code> pointer allows <code>CBrowserImpl</code> to call methods to update status bars, progress bars, and so forth.</p>

<pre>mpBrowserImpl-&gt;Init(mpBrowserFrameGlue, mWebBrowser);
mpBrowserImpl-&gt;AddRef();
</pre>

<p>Next the embedder-supplied chrome object is associated with the webbrowser. Note the use of an <code>nsCOMPtr</code>.</p>

<pre>mWebBrowser-&gt;SetContainerWindow
	(NS_STATIC_CAST(nsIWebBrowserChrome*, mpBrowserImpl));
nsCOMPtr&lt;nsIWebBrowserSetup&gt;setup(do_QueryInterface(mWebBrowser));
if (setup)
	setup-&gt;SetProperty(nsIWebBrowserSetup::SETUP_IS_CHROME_WRAPPER,PR_TRUE);
</pre>

<p>Then, the real webbrowser window is created.</p>

<pre>rv = NS_OK;
mBaseWindow = do_QueryInterface(mWebBrowser, &amp;rv);
if(NS_FAILED(rv))
return rv;
</pre>

<h3 id="Binding_a_window" name="Binding_a_window">Binding a window</h3>

<p>Basic location information is passed in.</p>

<pre>RECT rcLocation;
GetClientRect(&amp;rcLocation);
if(IsRectEmpty(&amp;rcLocation))
{
	rcLocation.bottom++;
	rcLocation.top++;
}
rv = mBaseWindow-&gt;InitWindow(nsNativeWidget(m_hWnd),
		nsnull,0, 0, rcLocation.right - rcLocation.left,
		rcLocation.bottom - rcLocation.top);
rv = mBaseWindow-&gt;Create();
</pre>

<p>Note the <code>m_hWnd</code> passed into the call above to <code>InitWindow()</code>. (<code>CBrowserView</code> inherits the <code>m_hWnd</code> from <code>CWnd</code>). This <code>m_hWnd</code> will be used as the parent window by the embeddable browser.</p>

<h3 id="Adding_a_listener" name="Adding_a_listener">Adding a listener</h3>

<p>The <code>BrowserImpl</code> object is added as an <a href="/en/nsIWebProgressListener" title="en/nsIWebProgressListener">nsIWebProgressListener</a>. It will now receive progress messages. These callbacks will be used to update the status/progress bars.</p>

<pre>nsWeakPtr weakling
	(dont_AddRef(NS_GetWeakReference(NS_STATIC_CAST(nsIWebProgressListener*,
			mpBrowserImpl))));
void mWebBrowser-&gt;AddWebBrowserListener(weakling, NS_GET_IID(nsIWebProgressListener));
</pre>

<p>Finally the webbrowser window is shown.</p>

<pre>mBaseWindow-&gt;SetVisibility(PR_TRUE);
</pre>

<h3 id="Using_session_history_to_navigate" name="Using_session_history_to_navigate">Using session history to navigate</h3>

<p>The pointer to <a class="external" href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIWebNavigation.html">nsIWebNavigation</a> saved above is used to move back through session history.</p>

<pre>void CBrowserView::OnNavBack()
{
if(mWebNav)
	mWebNav-&gt;GoBack();
}
</pre>

<h2 id="Appendix:_Data_Flow_Inside_Gecko" name="Appendix:_Data_Flow_Inside_Gecko">Appendix: Data Flow Inside Gecko</h2>

<p>While it isn't strictly necessary for embedders to understand how Gecko does what it does, a brief overview of the main structures involved as Gecko puts bits on a display may be helpful.</p>

<p><img alt="Image:EmbeddingBasicsa.gif" class="internal" src="/@api/deki/files/189/=EmbeddingBasicsa.gif"></p>

<p>HTML data comes into Gecko either from the network or a local source. The first thing that happens is that it is parsed, using Gecko's own HTML parser. Then the Content Model arranges this parsed data into a large tree. The tree is also known as the "Document" and its structure is based on the W3C Document Object Model. Any use of DOM APIs manipulates the data in the Content Model.</p>

<p>Next the data is put into frames using CSS and the Frame Constructor. A frame in this sense (which is not the same thing as an HTML frame) is basically an abstract box within which a DOM element will be displayed. This process produces a Frame Tree, which, like the Content Model, is a tree of data, but this time focused not on the logical relationship among the elements but on the underlying calculations needed to display the data. In the beginning a frame has no size. Using CSS rules specifying how the elements of the DOM should look when they are displayed, including information like font type or image size, the eventual size of each frame is calculated. Because the same data may need to be displayed in different ways -- to a monitor and to a printer, for example -- a particular Content Model may have more than one Frame Tree associated with it. In such a case, each individual Frame Tree would belong to a different "presentation" mode.</p>

<p>Calculations continue as new information flows into the system using a process called <strong>reflow</strong>. As information in the Frame Tree changes, the section of the Frame Tree involved is marked "dirty" by the Frame Constructor. Reflow repeatedly steps through the tree, processing every "dirty" item it encounters until all the items it encounters are "clean". Every item in the Frame Tree has a pointer back to its corresponding item in the Content Model. A change in the Content Model, say through using the DOM APIs to change an element from hidden to visible, produces an equivalent change in the Frame Tree. It's important to note that all of these operations are purely data manipulations. Painting to the display itself is not yet involved at this point.</p>

<p>The next stage is the View Manager. With a few small exceptions that have to do with prompting the Frame Constructor to load graphics, the View Manager is the first place in the process that accesses the native OS. Delaying OS access until this point both helps Gecko to run more quickly and makes cross-platform issues easier to deal with. The View Manger is the place where Gecko figures out where on the display the data will need to be drawn. It then tells the system that that area is "invalid" and needs to be repainted. The actual painting is managed by the gfx submodule, while other low-level system operations are run through the widget submodule, which handles things like platform specific event (mouse clicks and so forth) processing loops and accessing system defaults (colors, fonts, etc.) Both gfx and widget are system specific.</p>

<p>If you want to take a look at the code underlying these structures, the code for the Content Model can be found in <code>/mozilla/content</code>, for the Frame Constructor, CSS, and Reflow in <code>/mozilla/layout</code>, for the View Manager in <code>/mozilla/view</code>, and for the DOM APIs in <code>/mozilla/dom</code>.</p>

<div class="originaldocinfo">
<h2 id="Original_Document_Information" name="Original_Document_Information">Original Document Information</h2>

<ul>
 <li>Author(s): <a class="external" href="/mailto:jeev@jeev13@gmail.com" title="mailto:jeev@jeev13@gmail.com">Ellen Evans</a></li>
 <li>Last Updated Date: August 19, 2002</li>
 <li>Copyright Information: Copyright (C) <u>Creative Commons Attribution</u></li>
</ul>
</div>